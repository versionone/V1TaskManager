#!/bin/bash -e

#set -e

# ----- Variables -------------------------------------------------------------
# Variables in the build.properties file will be available to Jenkins
# build steps. Variables local to this script can be defined below.
. ./build.properties



# -----------------------------------------------------------------------------

# fix for jenkins inserting the windows-style path in $WORKSPACE
cd "$WORKSPACE"
export WORKSPACE=`pwd`



# ----- Utility functions -----------------------------------------------------

function winpath() {
  # Convert gitbash style path '/c/Users/Big John/Development' to 'c:\Users\Big John\Development',
  # via dumb substitution. Handles drive letters; incurs process creation penalty for sed.
  echo "$1" | sed -e 's|^/\(\w\)/|\1:\\|g;s|/|\\|g'
}

function parentwith() {  # used to find $WORKSPACE, below.
  # Starting at the current dir and progressing up the ancestors,
  # retuns the first dir containing $1. If not found returns pwd.
  SEARCHTERM="$1"
  DIR=`pwd`
  while [ ! -e "$DIR/$SEARCHTERM" ]; do
    NEWDIR=`dirname "$DIR"`
    if [ "$NEWDIR" = "$DIR" ]; then
      pwd
      return
    fi
    DIR="$NEWDIR"
  done
  echo "$DIR"
  }


# If we aren't running under jenkins. some variables will be unset.
# So set them to a reasonable value

if [ -z "$WORKSPACE" ]; then
  export WORKSPACE=`parentwith .git`;
fi

TOOLSDIRS=". $WORKSPACE/GetBuildTools $WORKSPACE/v1_build_tools $WORKSPACE/../v1_build_tools $WORKSPACE/nuget_tools"
for D in $TOOLSDIRS; do
  if [ -d "$D" ]; then
    export BUILDTOOLS_PATH="$D"
  fi
done
echo "Using $BUILDTOOLS_PATH for tools"

if [ -z "$DOTNET_PATH" ]; then
  for D in `cygpath -u "$SYSTEMROOT/Microsoft.NET/Framework/*"`; do
    if [ -d $D ]; then
      export DOTNET_PATH="$D"
    fi
  done
fi
echo "Using $DOTNET_PATH for .NET"

export PATH="$PATH:$BUILDTOOLS_PATH/bin:$DOTNET_PATH"

if [ -z "$SIGNING_KEY_DIR" ]; then
  export SIGNING_KEY_DIR=`pwd`;
fi

export SIGNING_KEY="$SIGNING_KEY_DIR/VersionOne.snk"

if [ -f "$SIGNING_KEY" ]; then 
  export SIGN_ASSEMBLY="true"
else
  export SIGN_ASSEMBLY="false"
  echo "Please place VersionOne.snk in `pwd` or $SIGNING_KEY_DIR to enable signing.";
fi

if [ -z "$VERSION_NUMBER" ]; then
  export VERSION_NUMBER="0.0.0"
fi

if [ -z "$BUILD_NUMBER" ]; then
  # presume local workstation, use date-based build number
  export BUILD_NUMBER=`date %H%M`  # hour + minute
fi

function update_nuget_deps() {
  PKGSCONFIG="${1:-packages.config}"
  if [ -f $PACKAGES_CONFIG ]
  then
    PKGSCONFIGW=`winpath "${PKGSCONFIG}"`
    PKGSDIRW=`winpath "$WORKSPACE/packages"`
    NuGet.exe install $PKGSCONFIGW -o $PKGSDIRW -Source $NUGET_FETCH_URL 
    NuGet.exe update $SOLUTION_FILE -Verbose -Source $NUGET_FETCH_URL
  fi
}



# ---- Produce .NET Metadata --------------------------------------------------

cat > "$WORKSPACE/V1TaskManager/Properties/AssemblyInfo.cs" <<EOF
// Auto generated by build_universal.sh at `date -u`

using System;
using System.Reflection;
using System.Resources;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

[assembly: AssemblyVersion("$VERSION_NUMBER.0")]
[assembly: AssemblyFileVersion("$VERSION_NUMBER.$BUILD_NUMBER")]
[assembly: AssemblyInformationalVersion("See $GITHUB_WEB_URL/wiki")]

[assembly: AssemblyDescription("$PRODUCT_NAME $Configuration Build")]
[assembly: AssemblyCompany("$ORGANIZATION_NAME")]
[assembly: AssemblyProduct("$PRODUCT_NAME")]
[assembly: AssemblyTitle("$PRODUCT_NAME")]
[assembly: AssemblyCopyright("Copyright $COPYRIGHT_RANGE, $ORGANIZATION_NAME, Licensed under modified BSD.")]

[assembly: AssemblyConfiguration("$Configuration")]
EOF



# ---- Clean solution ---------------------------------------------------------

# MSBuild.exe $SOLUTION_FILE /m /t:Clean



# ---- Update NuGet Packages --------------------------------------------------

update_nuget_deps



# ---- Build solution using msbuild -------------------------------------------

MSBuild.exe $SOLUTION_FILE /p:SignAssembly=$SIGN_ASSEMBLY /p:AssemblyOriginatorKeyFile=`winpath "$SIGNING_KEY"`


